[x] Download ZeOS
[x] Install ZeOS
---
		tar zxf zeos.tar.gz
---
[x] Generate ZeOS. This means generating the 'zeos.bin' file which contains the boot sector, the user code and the code for the operating system (the kernel).
---
		make
---
[x] Examine (and write down) the output of the previous command, as it explains the zeos.bin generation, specially which files are needed to generate the intermediate binaries.

gcc -m32 -E -Iinclude -traditional bootsect.S -o bootsect.s
as86 -0 -a -o bootsect.o bootsect.s
ld86 -0 -s -o bootsect bootsect.o
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o interrupt.o interrupt.c
gcc -m32 -E -Iinclude -o entry.s entry.S
as --32   -o entry.o entry.s
gcc -m32 -E -Iinclude -o sys_call_table.s sys_call_table.S
as --32   -o sys_call_table.o sys_call_table.s
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o io.o io.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o sched.o sched.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o sys.o sys.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o mm.o mm.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o devices.o devices.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o utils.o utils.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o hardware.o hardware.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o list.o list.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o system.o system.c
ld -melf_i386 -g -T system.lds -o system system.o interrupt.o entry.o sys_call_table.o io.o sched.o sys.o mm.o devices.o utils.o hardware.o list.o -L . -l zeos 
gcc -Wall -Wstrict-prototypes -g -o build build.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o user.o user.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o libc.o libc.c
ld -melf_i386 -g -T user.lds -o user user.o libc.o 
objcopy -O binary -R .note -R .comment -S system system.out
objcopy -O binary -R .note -R .comment -S user user.out
./build bootsect system.out user.out > zeos.bin
Boot sector 512 bytes.
System is 144 kB
User is 32 kB
Image is 176 kB


[x] Test your OS (without debugger, using 'bochs' binary):
---
		make emul
---
[x] Test your OS (again) manually:
---
		bochs -q
---
[x] Where is ZeOS hanged? (This is a typical situation in the lab where you need to know which code is being executed)
		- Look the dissassembly of the main function in the 'user' binary which corresponds to the main function in user.c.
---
			objdump -d user | less
---
		- It shows a listing of address + code

00100000 <main>:
  100000:       55                      push   %ebp
  100001:       89 e5                   mov    %esp,%ebp
  100003:       eb fe                   jmp    100003 <main+0x3>

		- Can you explain what is it doing?

Running an infinite while loop.

		- Start the internal debugger (it uses the 'bochs_nogdb' binary)
---
			make emuldbg
---
			- Start the execution of the image inside the debugger with the 'continue' command (or 'c').
			- Stop the execution of the emulation with Ctrl-C.
			- It now shows the next memory address to be loaded in the EIP (next instruction to be executed) and its corresponding value translated to assembly.
			- Which is this address? match it with the disassembly code shown before.

It's the same as the jmp in the disassembly.

[x] Modify the user code, adding a couple of functions 'inner' and 'outer' as explained in the Zeos document (section 2.5.2).
	Using the debugger you need to learn how to:
	- Stop the execution at a predefined position using a breakpoint: break ADDRESS

		break 0x100040
	- Examine content of the registers: r

eax: 0x001080e4 1081572
ecx: 0x0000022e 558
edx: 0x00007e1b 32283
ebx: 0x00012570 75120
esp: 0x0011bfa4 1163172
ebp: 0x0011bfb4 1163188
esi: 0x000e0200 918016
edi: 0x00003ff4 16372
eip: 0x00100040

	- Examine content of the stack: print-stack

 | STACK 0x0011bfa4 [0x00000000]
 | STACK 0x0011bfa8 [0x00000000]
 | STACK 0x0011bfac [0x00000000]
 | STACK 0x0011bfb0 [0x00000000]
 | STACK 0x0011bfb4 [0x0011bfd0]
 | STACK 0x0011bfb8 [0x0010008f]
 | STACK 0x0011bfbc [0x00000000]
 | STACK 0x0011bfc0 [0x00000000]
 | STACK 0x0011bfc4 [0x00000000]
 | STACK 0x0011bfc8 [0x00000000]
 | STACK 0x0011bfcc [0x00000000]
 | STACK 0x0011bfd0 [0x0011bfec]
 | STACK 0x0011bfd4 [0x00100026]
 | STACK 0x0011bfd8 [0x0000004b]
 | STACK 0x0011bfdc [0x00000000]
 | STACK 0x0011bfe0 [0x00000000]


	- Examine content of memory: x ADDRESS
	- Delete breakpoints: del

del 0x100040
	- Continue the execution of the image until a predefined point: continue
	- Execute a single assembly instruction: step
	- Execute a single assembly instruction, but if the instruction is a call, then executes it completely: next
	[x] Which is the final value of 'acum'?
main stores acum in -0x8(%ebp), so we check the value of ebp with r.
ebp is 1163244, so the value of acum is at 1163236
at this address, the value is 0x000107c5, which is 67525
	[x] Which is the value of 'acum' at the first iteration of 'outer'? Where is it stored? If it is in a register indicate which one, if it is in the stack indicate which address.
	It's stored in -0x8(%ebp)
  1000a1:       8b 45 f8                mov    -0x8(%ebp),%eax
We set a breakpoint at 0x1000a1 and we see that the value is: 0x000107c5, which is 67525 in decimal


	[x] Which is the value of 'acum' at the iteration 50 in the 'outer' loop? [This question is hard, do not invest more than 15 minutes]
We talked about this in class, adding an if (iter==50) and add a breakpoint there. We have not implemented it.


[x] Do the same using the external debugger (GDB). Try the TUI.
(gdb) break user.c:20
Breakpoint 1 at 0x1000a1: file user.c, line 20.
(gdb) c
Continuing.

Breakpoint 1, outer (n=75) at user.c:20
20		return acum;
1: x/i $eip
=> 0x1000a1 <outer+58>:	mov    -0x8(%ebp),%eax
(gdb) print acum
$1 = 67525


We will do the rest before the next session.
[ ] Add the function 'add' explained in the Zeos document. Compile it and write down the assembly code of this function.
[ ] Create an assembler version of the 'add' C function using asembler inline, and test that it works as expected as explained in the Zeos document (section 2.5.3).
